# scripts/create_fix_pull_request.py

import json
import traceback
import requests
import os
import google.generativeai as genai  # Needed for Gemini API
import base64  # Needed if creating blobs from raw file content (Git Database API)
import logging # Import logging

# Setup logger for this module
logger = logging.getLogger(__name__)

# --- Configuration ---
# IMPORTANT: Set these environment variables in your Railway service settings.
GIT_HOST_API_BASE_URL = os.getenv("GIT_HOST_API_BASE_URL", "https://api.github.com")  # Default to GitHub REST API v3
GIT_REPO_OWNER = os.getenv("GIT_REPO_OWNER")  # The owner of the repository (e.g., "your-org")
GIT_REPO_NAME = os.getenv("GIT_REPO_NAME")  # The name of the repository (e.g., "your-repo")
GIT_API_TOKEN = os.getenv("GIT_API_TOKEN")  # GitHub Personal Access Token (PAT) or equivalent
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY") # API key for Google Gemini
DEFAULT_BASE_BRANCH = os.getenv("DEFAULT_BASE_BRANCH", "main")  # Branch to base new fix branches on

# Define standard headers for GitHub API requests (adjust if using a different Git host)
GITHUB_HEADERS = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {GIT_API_TOKEN}" if GIT_API_TOKEN else None, # Add token if available
    "X-GitHub-Api-Version": "2022-11-28", # GitHub API version header
    # "Content-Type": "application/json", # Often needed for POST/PATCH requests
}

# Check for required Git environment variables
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
    logger.error("Missing one or more required Git environment variables (GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN). Pull request creation will not work.")
    # Setting GIT_API_TOKEN to None will disable authenticated calls via GITHUB_HEADERS
    GIT_API_TOKEN = None
    # You might want to raise an exception during startup instead if these are critical
    # raise ValueError("Missing Git configuration environment variables")


# Configure Gemini API client
gemini_client = None # Initialize client to None
if GEMINI_API_KEY:
    try:
        # Configure the genai library with the API key
        genai.configure(api_key=GEMINI_API_KEY)
        # You can optionally create a client instance here if needed,
        # but the functions often use the configured global state.
        # If using the newer client classes, you'd initialize like:
        # gemini_client = genai.GenerativeModel('gemini-1.5-flash-latest')
        logger.info("Gemini API configured successfully.")
        # Optional: Check available models or do a test call if needed during startup
        # for m in genai.list_models(): logger.info(f"Available model: {m.name}")
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {e}", exc_info=True) # Log error with traceback
        GEMINI_API_KEY = None # Disable Gemini if configuration fails
else:
    logger.warning("GEMINI_API_KEY environment variable is not set. PR body will not be generated by Gemini.")


# --- Helper function to generate PR body using Gemini ---
async def generate_pr_body_with_gemini(issue_id: str, code_diff: str, diagnosis_details: dict, validation_results: dict) -> str:
    """
    Generates a professional PR body using the Gemini API.
    Made async as genai.generate_content is awaitable.

    Args:
        issue_id (str): The ID of the issue.
        code_diff (str): The patch in diff format.
        diagnosis_details (dict): Details from the diagnosis step.
        validation_results (dict): Results from the validation step.

    Returns:
        str: The generated PR body text, or an error message.
    """
    # Check if Gemini API key is configured
    if not GEMINI_API_KEY:
        logger.warning("Gemini API key missing, using fallback PR body template.")
        return "LLM configuration missing. PR body generated from template."

    try:
        # Use the configured API key implicitly, or pass explicitly if needed
        # Use the appropriate model name
        model = genai.GenerativeModel('gemini-1.5-flash-latest') # Or your preferred Gemini model

        # Prepare the prompt using the provided information
        prompt = f"""
You are an AI assistant tasked with writing a professional and concise Pull Request description based on a bug fix and its validation.

Use the following information:

Issue ID: {issue_id}

Diagnosis Summary:
{diagnosis_details.get('summary', 'N/A')}

Validation Results:
{validation_results.get('summary', 'N/A')}

Code Changes (Unified Diff Format):
{code_diff}

Draft a Pull Request description incorporating the Issue ID, summarizing the diagnosis and validation, and briefly describing the code changes based on the diff. Format it clearly for a technical audience.
"""
        logger.info(f"Sending prompt to Gemini for PR body for issue {issue_id}...")
        # Use the awaitable generate_content method
        response = await model.generate_content(contents=[prompt])

        # Extract text from the response
        if hasattr(response, 'text') and response.text:
            logger.info(f"Successfully generated PR body for issue {issue_id}.")
            return response.text.strip()
        else:
            logger.warning(f"Gemini generated no text for PR body for issue {issue_id}. Raw response: {response}")
            return "Gemini generated no text for the PR body." # Return a default message if no text is generated

    except Exception as e:
        # Log the exception details
        logger.error(f"Error generating PR body with Gemini for issue {issue_id}: {e}", exc_info=True)
        # Return an informative error message in the PR body
        return f"Error generating PR body with AI: {e}"


# --- Main function to create the Pull Request ---
# This is the function that the autonomous_router imports and calls.
async def create_pull_request(
    issue_id: str,
    patch_diff: str,
    diagnosis_details: dict,
    validation_results: dict
):
    """
    Creates a pull request on the configured Git hosting platform (defaulting to GitHub)
    with the proposed patch.

    Args:
        issue_id (str): The ID of the issue being fixed.
        patch_diff (str): The suggested code changes in unified diff format.
        diagnosis_details (dict): Information gathered during diagnosis. Expected keys:
                                  'relevant_files': list of files touched,
                                  'repository': repo name (optional, falls back to config)
                                  ... other diagnosis info
        validation_results (dict): Results from validating the patch. Expected keys:
                                   'status': 'Passed' or 'Failed',
                                   'summary': validation summary
                                   ... other validation info

    Returns:
        dict: A dictionary containing details about the created PR (e.g., PR URL, PR number),
              or an error key if creation fails. Expected keys: 'pr_url', 'pr_number', 'message', 'error'.
    """
    logger.info(f"Starting PR creation process for issue: {issue_id}")

    # --- Basic Configuration Check ---
    if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
        error_msg = "Git configuration missing. Cannot create pull request."
        logger.error(error_msg)
        return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}

    # Determine the target repository details - prioritize diagnosis details if available
    repo_owner = diagnosis_details.get('repository_owner') or GIT_REPO_OWNER # Assuming diagnosis might provide owner
    repo_name = diagnosis_details.get('repository_name') or GIT_REPO_NAME # Assuming diagnosis might provide name

    if not all([repo_owner, repo_name]):
         error_msg = "Repository owner or name not specified in config or diagnosis."
         logger.error(error_msg)
         return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}

    logger.info(f"Target Repository: {repo_owner}/{repo_name}")

    # Determine the base branch - prioritize diagnosis details or use default config
    # Assuming diagnosis_details might suggest a base branch
    base_branch = diagnosis_details.get('base_branch') or DEFAULT_BASE_BRANCH
    logger.info(f"Base Branch: {base_branch}")

    # Generate a unique branch name for the fix
    # Example: fix/issue-BUG-123-timestamp
    timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
    fix_branch_name = f"fix/issue-{issue_id}-{timestamp}".replace("/", "-").replace(" ", "-").lower() # Sanitize for branch name
    logger.info(f"Proposed Fix Branch: {fix_branch_name}")


    # --- Git API Interaction Logic ---
    # This is the complex part where you interact with the Git hosting API.
    # Steps typically involve:
    # 1. Get the SHA of the latest commit on the base branch.
    # 2. Create a new branch based on that commit SHA.
    # 3. Determine the changes needed based on the patch_diff (add, modify, delete files).
    # 4. Get the current SHA of the files that are being modified/deleted.
    # 5. Create new blob(s) for the modified files using the updated content.
    # 6. Create a new tree object referencing the new blobs and unchanged files.
    # 7. Create a new commit object referencing the new tree and the base commit.
    # 8. Update the reference of the new branch to point to the new commit.
    # 9. Create the pull request between the base branch and the new fix branch.

    # --- PLACEHOLDER IMPLEMENTATION ---
    # This section needs to be replaced with actual API calls to GitHub/GitLab/etc.
    # Using requests library as an example, but dedicated libraries like Octokit.py (GitHub)
    # are often easier to use.

    try:
        logger.info(f"Simulating Git operations and PR creation for {issue_id}")

        # --- Example Step 1: Get Base Branch SHA ---
        # You would make a GET request like:
        # url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/ref/heads/{base_branch}"
        # response = requests.get(url, headers=GITHUB_HEADERS)
        # response.raise_for_status()
        # base_branch_sha = response.json()['object']['sha']
        # logger.info(f"Base branch ({base_branch}) SHA: {base_branch_sha}")
        base_branch_sha = "mock_base_sha_12345" # Placeholder

        # --- Example Step 2: Create New Branch ---
        # You would make a POST request like:
        # url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/refs"
        # payload = {
        #     "ref": f"refs/heads/{fix_branch_name}",
        #     "sha": base_branch_sha
        # }
        # response = requests.post(url, headers=GITHUB_HEADERS, json=payload)
        # response.raise_for_status()
        logger.info(f"Simulated creating branch: {fix_branch_name}")


        # --- Step 3-8: Apply Patch, Create Blobs, Tree, Commit, Update Ref ---
        # This is highly complex and depends on the patch format and Git API used.
        # For a diff patch, you'd typically need to:
        # - Parse the diff to find which files are added, modified, or deleted.
        # - For modified/deleted files, get their current SHA from the base branch tree.
        # - Get the content of modified files from the base branch.
        # - Apply the patch content to the base content to get the new file content.
        # - Create blobs for new/modified files (POST /repos/:owner/:repo/git/blobs).
        # - Build a new tree object representing the state after the patch (POST /repos/:owner/:repo/git/trees).
        # - Create a new commit object pointing to the new tree and the base commit (POST /repos/:owner/:repo/git/commits).
        # - Update the new branch's reference to point to this new commit (PATCH /repos/:owner/:repo/git/refs/heads/:branch).
        # --- This is where most of your Git API implementation logic goes ---
        new_commit_sha = "mock_new_commit_sha_67890" # Placeholder
        logger.info(f"Simulated applying patch and creating commit: {new_commit_sha}")


        # --- Step 9: Generate PR Body ---
        # Use the helper function to generate the PR body content
        pr_body = await generate_pr_body_with_gemini(issue_id, patch_diff, diagnosis_details, validation_results)
        logger.info(f"Generated PR body (snippet): {pr_body[:300]}...") # Log snippet

        # --- Example Step 10: Create Pull Request ---
        # You would make a POST request like:
        # url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/pulls"
        # payload = {
        #     "title": f"Fix for Issue {issue_id}", # Or generate a title
        #     "body": pr_body,
        #     "head": fix_branch_name, # The branch with your changes
        #     "base": base_branch      # The branch you want to merge into
        # }
        # response = requests.post(url, headers=GITHUB_HEADERS, json=payload)
        # response.raise_for_status()
        # pr_details = response.json()
        # pr_url = pr_details.get('html_url')
        # pr_number = pr_details.get('number')
        # logger.info(f"Successfully created PR: {pr_url}")
        # --- End of Placeholder ---

        # Placeholder return values on success
        pr_url = f"https://github.com/{repo_owner}/{repo_name}/pull/mock_123_for_{issue_id}" # Replace with actual PR URL
        pr_number = 123 # Replace with actual PR number
        logger.info(f"Successfully simulated PR creation for issue {issue_id}. PR URL: {pr_url}")

        return {
            "pr_url": pr_url,
            "pr_number": pr_number,
            "message": f"Pull request created successfully for issue {issue_id}. PR: {pr_url}",
            "error": None # Explicitly set error to None on success
        }

    except requests.exceptions.RequestException as e:
        # Handle errors during HTTP requests to the Git API
        error_msg = f"Git API request failed during PR creation for issue {issue_id}: {e}"
        logger.error(error_msg, exc_info=True)
        # Try to include API response body if available
        backend_detail = "N/A"
        if e.response is not None:
             try:
                 backend_detail = e.response.json()
             except json.JSONDecodeError:
                 backend_detail = e.response.text
             error_msg += f" - API Response: {backend_detail}"

        return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg, "backend_detail": backend_detail}

    except Exception as e:
        # Catch any other unexpected errors
        error_msg = f"An unexpected error occurred during PR creation for issue {issue_id}: {e}"
        logger.error(error_msg, exc_info=True)
        return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}

# Note: This file defines the 'create_pull_request' function which needs to be
# imported by scripts like autonomous_router.py. It does NOT define an APIRouter.
