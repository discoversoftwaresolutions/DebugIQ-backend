# backend/scripts/create_fix_pull_request.py

import json
import traceback
import httpx # Import the asynchronous HTTP client
import os
import google.generativeai as genai
import base64 # Needed if creating blobs from raw file content (Git Database API)
import logging
import datetime # Needed for timestamp in branch name

# Setup logger for this module
logger = logging.getLogger(__name__)

# --- Configuration ---
# IMPORTANT: Set these environment variables in your Railway service settings.
GIT_HOST_API_BASE_URL = os.getenv("GIT_HOST_API_BASE_URL", "https://api.github.com") # Default to GitHub REST API v3
GIT_REPO_OWNER = os.getenv("GIT_REPO_OWNER") # The owner of the repository (e.g., "your-org")
GIT_REPO_NAME = os.getenv("GIT_REPO_NAME") # The name of the repository (e.g., "your-repo")
# GIT_API_TOKEN = os.getenv("GIT_API_TOKEN") # No longer needed for direct PR creation here
GITHUB_DISPATCH_TOKEN = os.getenv("GITHUB_DISPATCH_TOKEN") # New token for triggering workflows (needs 'workflow' scope)
GITHUB_PR_WORKFLOW_FILENAME = os.getenv("GITHUB_PR_WORKFLOW_FILENAME") # New: Filename of the PR creation workflow file (e.g., 'create-pr-workflow.yml')
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY") # API key for Google Gemini
DEFAULT_BASE_BRANCH = os.getenv("DEFAULT_BASE_BRANCH", "main") # Branch to base new fix branches on

# Define standard headers for GitHub API requests (adjust if using a different Git host)
# These headers might be used for other Git interactions if you add them,
# but the dispatch call uses headers with the dispatch token.
GITHUB_HEADERS = {
    "Accept": "application/vnd.github.h3+json",
    "Authorization": f"token {os.getenv('GIT_API_TOKEN')}", # Keep if GIT_API_TOKEN is used elsewhere, otherwise remove
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json", # Often needed for POST/PATCH requests
}


# Check for required Git environment variables needed for the trigger
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GITHUB_DISPATCH_TOKEN, GITHUB_PR_WORKFLOW_FILENAME]):
    logger.error(
        "Missing one or more required Git environment variables needed for Workflow Dispatch (GIT_REPO_OWNER, GIT_REPO_NAME, GITHUB_DISPATCH_TOKEN, GITHUB_PR_WORKFLOW_FILENAME). "
        "PR creation workflow triggering will not work."
    )
    # We'll allow startup but the function will return an error if called without these


# Configure Gemini API client (assuming this configuration is sufficient globally)
if GEMINI_API_KEY:
    try:
        # Configure the genai library with the API key
        genai.configure(api_key=GEMINI_API_KEY)
        logger.info("Gemini API configured successfully.")
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {e}", exc_info=True)
        GEMINI_API_KEY = None # Disable Gemini if configuration fails
else:
    logger.warning("GEMINI_API_KEY environment variable is not set. PR body will not be generated by Gemini.")


# --- Helper function to generate PR body using Gemini (already async) ---
async def generate_pr_body_with_gemini(issue_id: str, code_diff: str, diagnosis_details: dict, validation_results: dict) -> str:
    """
    Generates a professional PR body using the Gemini API asynchronously.

    Args:
        issue_id (str): The ID of the issue.
        code_diff (str): The patch in diff format.
        diagnosis_details (dict): Details from the diagnosis step (e.g., summary).
        validation_results (dict): Results from the validation step (e.g., summary, status).

    Returns:
        str: The generated PR body text, or an informative error message if generation fails.
    """
    if not GEMINI_API_KEY:
        logger.warning("Gemini API key missing, using fallback PR body template for PR body generation.")
        # Fallback template using available data
        diagnosis_summary = diagnosis_details.get('summary', 'N/A')
        validation_summary = validation_results.get('summary', 'N/A')
        # Removed {code_changes} from here as requested by user, resulting in empty code block in fallback
        # code_changes = code_diff if code_diff else "No changes available." # This variable is no longer used below

        return f"""
## DebugIQ Automated Pull Request

**Issue ID:** {issue_id}

### Diagnosis Summary:
{diagnosis_summary}

### Validation Results:
{validation_summary}

### Code Changes:
```diff
# Code changes diff would normally go here, but LLM is not configured.# Extract text from the response and handle potential lack of text
    if hasattr(response, 'text') and response.text:
        logger.info(f"Successfully generated PR body for issue {issue_id}.")
        return response.text.strip()
    else:
        # Log if the response was blocked by safety settings
        if hasattr(response, 'prompt_feedback') and response.prompt_feedback.block_reason:
             block_reason = response.prompt_feedback.block_reason
             logger.warning(f"Gemini blocked PR body generation for issue {issue_id}. Reason: {block_reason}. Raw response: {response}")
             return f"AI PR body generation blocked by safety policy (Reason: {block_reason}). Please write the PR body manually."
        else:
            logger.warning(f"Gemini generated no text for PR body for issue {issue_id}. Raw response: {response}")
            return "Gemini generated no text for the PR body. Please write the PR body manually." # Return a default message

except Exception as e:
    # Log the exception details using the logger
    logger.error(f"Error generating PR body with Gemini for issue {issue_id}: {e}", exc_info=True)
    # Return an informative error message in the PR body
    return f"Error generating PR body with AI: {e}. Please write the PR body manually."Args:
    issue_id (str): The ID of the issue being fixed.
    patch_diff (str): The suggested code changes in unified diff format.
    diagnosis_details (dict): Information gathered during diagnosis.
    validation_results (dict): Results from validating the patch.

Returns:
    dict: A dictionary indicating the workflow trigger status. Expected keys:
          'workflow_url': URL to the workflow run page (if successful)
          'message': Status message
          'error': Error message if triggering failed
"""
logger.info(f"Attempting to trigger GitHub Actions workflow for issue: {issue_id}")

# --- Configuration Check for Workflow Trigger ---
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GITHUB_DISPATCH_TOKEN, GITHUB_PR_WORKFLOW_FILENAME]):
    error_msg = "GitHub Actions Workflow Dispatch configuration missing. Cannot trigger PR creation workflow."
    logger.error(error_msg)
    return {"workflow_url": None, "message": error_msg, "error": error_msg}

repo_owner = diagnosis_details.get('repository_owner') or GIT_REPO_OWNER
repo_name = diagnosis_details.get('repository_name') or GIT_REPO_NAME
base_branch = diagnosis_details.get('base_branch') or DEFAULT_BASE_BRANCH # Workflow needs to run on this branch


if not all([repo_owner, repo_name]):
     error_msg = "Repository owner or name not specified in config or diagnosis details."
     logger.error(error_msg)
     return {"workflow_url": None, "message": error_msg, "error": error_msg}

logger.info(f"Target Repository for Workflow: {repo_owner}/{repo_name}")
logger.info(f"Workflow File: {GITHUB_PR_WORKFLOW_FILENAME}")
logger.info(f"Workflow Base Branch: {base_branch}")


# --- Generate PR Body (Workflow might need this as input) ---
pr_body = await generate_pr_body_with_gemini(issue_id, patch_diff, diagnosis_details, validation_results)
logger.info(f"Generated PR body (snippet for workflow input): {pr_body[:300]}...")


# --- Construct the GitHub API URL for workflow dispatch ---
# The workflow_id is the workflow file name (e.g., 'create-pr-workflow.yml')
# See https://docs.github.com/en/rest/actions/workflows#create-a-workflow-dispatch-event
dispatch_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/actions/workflows/{GITHUB_PR_WORKFLOW_FILENAME}/dispatches"


# --- Prepare the payload for the workflow_dispatch event ---
# The GitHub Actions workflow will receive these inputs.
# Make sure your .github/workflows/your_workflow_file.yml has 'workflow_dispatch'
# configured with inputs matching these keys.
dispatch_payload = {
    "ref": base_branch, # The branch the workflow file lives on (usually main or master)
    "inputs": {
        "issue_id": issue_id,
        "patch_diff": patch_diff, # Pass the diff as an input
        "pr_body": pr_body,       # Pass the generated PR body as an input
        # Pass other relevant data as inputs for the workflow
        "repo_owner": repo_owner,
        "repo_name": repo_name,
        "base_branch": base_branch,
        "diagnosis_summary": diagnosis_details.get('summary', 'N/A'),
        "validation_summary": validation_results.get('summary', 'N/A'),
        "validation_status": validation_results.get('status', 'Unknown'),
    }
}
# Log payload excluding potentially large patch_diff and pr_body
log_payload = {k: v for k, v in dispatch_payload.items() if k != 'inputs' or ('patch_diff' not in v and 'pr_body' not in v)}
if 'inputs' in dispatch_payload:
    log_payload['inputs'] = {k: v for k, v in dispatch_payload['inputs'].items() if k not in ['patch_diff', 'pr_body']}
logger.debug(f"Workflow dispatch payload: {log_payload}")


# --- Headers for the dispatch API call - Use the dispatch token ---
# Note: Use the GITHUB_DISPATCH_TOKEN for Authorization for workflow_dispatch
# The other GITHUB_HEADERS defined above might be for different Git API interactions
dispatch_headers = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {GITHUB_DISPATCH_TOKEN}", # Use the dispatch token here
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",
}

# Initialize an async HTTP client for making the request
async with httpx.AsyncClient() as client:
    try:
        # Make the asynchronous HTTP POST request to trigger the workflow
        logger.info(f"Making POST request to trigger workflow at: {dispatch_url}")
        response_dispatch = await client.post(dispatch_url, headers=dispatch_headers, json=dispatch_payload)

        # GitHub returns 204 No Content on successful workflow dispatch
        if response_dispatch.status_code == 204:
             logger.info(f"✅ Successfully triggered GitHub Actions workflow '{GITHUB_PR_WORKFLOW_FILENAME}' for issue {issue_id}.")
             # We don't get the workflow run URL immediately, user checks Actions tab
             # Construct a likely URL pattern for the workflow runs list
             workflow_runs_url = f"https://github.com/{repo_owner}/{repo_name}/actions/workflows/{GITHUB_PR_WORKFLOW_FILENAME}"
             message = f"GitHub Actions workflow '{GITHUB_PR_WORKFLOW_FILENAME}' triggered for issue {issue_id}. Check the GitHub Actions page: {workflow_runs_url} for run details."
             return {
                 "workflow_url": workflow_runs_url, # Link to the specific workflow's runs list
                 "message": message,
                 "error": None
             }
        else:
             # Handle non-204 responses as potential errors
             error_msg = f"GitHub Actions dispatch API returned unexpected status code {response_dispatch.status_code} for issue {issue_id}."
             logger.error(error_msg)
             backend_detail = "N/A"
             if response_dispatch.text:
                 try:
                     backend_detail = response_dispatch.json()
                 except json.JSONDecodeError:
                     backend_detail = response_dispatch.text[:500] # Log snippet of non-JSON response
             error_msg += f" - API Response: {backend_detail}"

             return {"workflow_url": None, "message": f"Workflow Trigger API Error: {error_msg}", "error": error_msg, "backend_detail": backend_detail}


    # --- Use httpx specific exceptions for HTTP errors ---
    except httpx.HTTPStatusError as e:
        # Handle errors during HTTP requests (e.g., 404 for workflow file not found, 401 auth error)
        error_msg = f"GitHub Actions dispatch HTTP error for issue {issue_id}: {e}"
        logger.error(error_msg, exc_info=True)
        backend_detail = "N/A"
        if e.response is not None:
             try:
                 # Attempt to parse JSON error response, fallback to text
                 if e.response.text: backend_detail = e.response.json()
                 else: backend_detail = "Empty response body"
             except json.JSONDecodeError:
                  backend_detail = e.response.text[:500] if e.response.text else "Non-JSON response body" # Log snippet
             error_msg += f" - API Response: {backend_detail}"

        return {"workflow_url": None, "message": f"Workflow Trigger HTTP Error: {error_msg}", "error": error_msg, "backend_detail": backend_detail}

    except httpx.RequestError as e:
        # Handle network or request-specific errors (e.g., connection failed, timeout)
        error_msg = f"GitHub Actions dispatch request error for issue {issue_id}: {e}"
        logger.error(error_msg, exc_info=True)
        return {"workflow_url": None, "message": f"Workflow Trigger Request Error: {error_msg}", "error": error_msg}

    except Exception as e:
        # Catch any other unexpected errors
        error_msg = f"An unexpected error occurred during GitHub Actions trigger for issue {issue_id}: {e}"
        logger.error(error_msg, exc_info=True)
        return {"workflow_url": None, "message": f"Unexpected Error during Workflow Trigger: {error_msg}", "error": error_msg}
