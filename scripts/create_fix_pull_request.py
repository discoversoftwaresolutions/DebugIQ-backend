# backend/scripts/create_fix_pull_request.py

import json
import traceback
import httpx  # Import the asynchronous HTTP client
import os
import google.generativeai as genai
import base64  # Needed if creating blobs from raw file content (Git Database API)
import logging
from datetime import datetime  # Needed for timestamp in branch name

# Setup logger for this module
logger = logging.getLogger(__name__)

# --- Configuration ---
# IMPORTANT: Set these environment variables in your Railway service settings.
GIT_HOST_API_BASE_URL = os.getenv("GIT_HOST_API_BASE_URL", "https://api.github.com")  # Default to GitHub REST API v3
GIT_REPO_OWNER = os.getenv("GIT_REPO_OWNER")  # The owner of the repository (e.g., "your-org")
GIT_REPO_NAME = os.getenv("GIT_REPO_NAME")  # The name of the repository (e.g., "your-repo")
GIT_API_TOKEN = os.getenv("GIT_API_TOKEN")  # GitHub Personal Access Token (PAT) or equivalent
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")  # API key for Google Gemini
DEFAULT_BASE_BRANCH = os.getenv("DEFAULT_BASE_BRANCH", "main")  # Branch to base new fix branches on

# Define standard headers for GitHub API requests (adjust if using a different Git host)
GITHUB_HEADERS = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {GIT_API_TOKEN}" if GIT_API_TOKEN else None,
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",  # Often needed for POST/PATCH requests
}

# Check for required Git environment variables
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
    logger.error(
        "Missing one or more required Git environment variables (GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN). "
        "Pull request creation will not work."
    )
    GIT_API_TOKEN = None  # Disable authenticated calls if token is missing

# Configure Gemini API client
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        logger.info("Gemini API configured successfully.")
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {e}", exc_info=True)
        GEMINI_API_KEY = None  # Disable Gemini if configuration fails
else:
    logger.warning("GEMINI_API_KEY environment variable is not set. PR body will not be generated by Gemini.")


# --- Helper function to generate PR body using Gemini ---
async def generate_pr_body_with_gemini(issue_id: str, code_diff: str, diagnosis_details: dict, validation_results: dict) -> str:
    """
    Generates a professional PR body using the Gemini API asynchronously.

    Args:
        issue_id (str): The ID of the issue.
        code_diff (str): The patch in diff format.
        diagnosis_details (dict): Details from the diagnosis step (e.g., summary).
        validation_results (dict): Results from the validation step (e.g., summary, status).

    Returns:
        str: The generated PR body text, or an informative error message if generation fails.
    """
    if not GEMINI_API_KEY:
        logger.warning("Gemini API key missing, using fallback PR body template for PR body generation.")
        diagnosis_summary = diagnosis_details.get('summary', 'N/A')
        validation_summary = validation_results.get('summary', 'N/A')
        code_changes = code_diff if code_diff else "No changes available."
        return f"""
## DebugIQ Automated Pull Request

**Issue ID:** {issue_id}

### Diagnosis Summary:
{diagnosis_summary}

### Validation Results:
{validation_summary}

### Code Changes:
{code_changes}
"""

    try:
        # Assuming genai has a method to generate text
        response = genai.generate_text(
            prompt=f"Generate a pull request body for issue {issue_id} with the following details: diagnosis: {diagnosis_details}, "
                   f"validation: {validation_results}, code diff: {code_diff}"
        )
        return response.text
    except Exception as e:
        logger.error(f"Error generating PR body with Gemini: {e}", exc_info=True)
        return "Error generating PR body."


# --- Main asynchronous function to create the Pull Request ---
async def create_pull_request(
    issue_id: str,
    patch_diff: str,
    diagnosis_details: dict,
    validation_results: dict
):
    """
    Creates a pull request on the configured Git hosting platform (defaulting to GitHub)
    with the proposed patch. Uses an asynchronous HTTP client for Git API calls.

    Args:
        issue_id (str): The ID of the issue being fixed.
        patch_diff (str): The suggested code changes in unified diff format.
        diagnosis_details (dict): Information gathered during diagnosis.
        validation_results (dict): Results from validating the patch.

    Returns:
        dict: A dictionary containing details about the created PR (e.g., PR URL, PR number),
              or an error key if creation fails.
    """
    logger.info(f"Starting PR creation process for issue: {issue_id}")

    if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
        error_msg = "Git configuration missing (GIT_REPO_OWNER, GIT_REPO_NAME, or GIT_API_TOKEN). Cannot create pull request."
        logger.error(error_msg)
        return {"error": error_msg}

    repo_owner = diagnosis_details.get('repository_owner') or GIT_REPO_OWNER
    repo_name = diagnosis_details.get('repository_name') or GIT_REPO_NAME
    base_branch = diagnosis_details.get('base_branch') or DEFAULT_BASE_BRANCH

    sanitized_issue_id = "".join(c if c.isalnum() else '-' for c in issue_id).strip('-')
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    fix_branch_name = f"fix/issue-{sanitized_issue_id}-{timestamp}".lower()

    async with httpx.AsyncClient() as client:
        try:
            ref_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/ref/heads/{base_branch}"
            response_ref = await client.get(ref_url, headers=GITHUB_HEADERS)
            response_ref.raise_for_status()
            base_branch_sha = response_ref.json()['object']['sha']

            create_ref_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/refs"
            create_ref_payload = {"ref": f"refs/heads/{fix_branch_name}", "sha": base_branch_sha}
            response_create_ref = await client.post(create_ref_url, headers=GITHUB_HEADERS, json=create_ref_payload)

            if response_create_ref.status_code == 422:
                logger.warning(f"Branch '{fix_branch_name}' already exists.")

            pr_body = await generate_pr_body_with_gemini(issue_id, patch_diff, diagnosis_details, validation_results)
            create_pr_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/pulls"
            pr_payload = {
                "title": f"Fix for Issue {issue_id}: {diagnosis_details.get('summary', 'Automated fix')}",
                "body": pr_body,
                "head": fix_branch_name,
                "base": base_branch,
            }
            response_pr = await client.post(create_pr_url, headers=GITHUB_HEADERS, json=pr_payload)
            response_pr.raise_for_status()
            pr_details = response_pr.json()

            return {"pr_url": pr_details.get('html_url'), "pr_number": pr_details.get('number')}
        except Exception as e:
            logger.error(f"Error during PR creation: {e}", exc_info=True)
            return {"error": str(e)}
