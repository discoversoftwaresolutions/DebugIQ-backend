import json
import traceback
import httpx  # Import the asynchronous HTTP client
import os
import google.generativeai as genai
import base64  # Needed if creating blobs from raw file content (Git Database API)
import logging
from datetime import datetime  # Needed for timestamp in branch name

# Setup logger for this module
logger = logging.getLogger(__name__)

# --- Configuration ---
# IMPORTANT: Set these environment variables in your Railway service settings.
GIT_HOST_API_BASE_URL = os.getenv("GIT_HOST_API_BASE_URL", "https://api.github.com")  # Default to GitHub REST API v3
GIT_REPO_OWNER = os.getenv("GIT_REPO_OWNER")  # The owner of the repository (e.g., "your-org")
GIT_REPO_NAME = os.getenv("GIT_REPO_NAME")  # The name of the repository (e.g., "your-repo")
GITHUB_DISPATCH_TOKEN = os.getenv("GITHUB_DISPATCH_TOKEN")  # Token for triggering workflows (needs 'workflow' scope)
GITHUB_PR_WORKFLOW_FILENAME = os.getenv("GITHUB_PR_WORKFLOW_FILENAME")  # Workflow file name (e.g., 'create-pr-workflow.yml')
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")  # API key for Google Gemini
DEFAULT_BASE_BRANCH = os.getenv("DEFAULT_BASE_BRANCH", "main")  # Branch to base new fix branches on

# Define standard headers for GitHub API requests
GITHUB_HEADERS = {
    "Accept": "application/vnd.github.h3+json",
    "Authorization": f"token {os.getenv('GIT_API_TOKEN')}",
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",
}

# Check for required Git environment variables
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GITHUB_DISPATCH_TOKEN, GITHUB_PR_WORKFLOW_FILENAME]):
    logger.error(
        "Missing one or more required Git environment variables needed for Workflow Dispatch. "
        "PR creation workflow triggering will not work."
    )

# Configure Gemini API client
if GEMINI_API_KEY:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        logger.info("Gemini API configured successfully.")
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {e}", exc_info=True)
        GEMINI_API_KEY = None
else:
    logger.warning("GEMINI_API_KEY environment variable is not set. PR body will not be generated by Gemini.")

# --- Helper function to generate PR body using Gemini ---
async def generate_pr_body_with_gemini(issue_id: str, code_diff: str, diagnosis_details: dict, validation_results: dict) -> str:
    """
    Generates a professional PR body using the Gemini API asynchronously.

    Args:
        issue_id (str): The ID of the issue.
        code_diff (str): The patch in diff format.
        diagnosis_details (dict): Details from the diagnosis step.
        validation_results (dict): Results from the validation step.

    Returns:
        str: The generated PR body text, or an informative error message if generation fails.
    """
    if not GEMINI_API_KEY:
        logger.warning("Gemini API key missing, using fallback PR body template.")
        diagnosis_summary = diagnosis_details.get('summary', 'N/A')
        validation_summary = validation_results.get('summary', 'N/A')
        return f"""
## DebugIQ Automated Pull Request

**Issue ID:** {issue_id}

### Diagnosis Summary:
{diagnosis_summary}

### Validation Results:
{validation_summary}

### Code Changes:
```diff
# Code changes diff would normally go here, but LLM is not configured.try:
    response = genai.generate_text(
        prompt=f"Generate a pull request body for issue {issue_id} with the following details: diagnosis: {diagnosis_details}, "
               f"validation: {validation_results}, code diff: {code_diff}"
    )
    if hasattr(response, 'text') and response.text:
        return response.text.strip()
    elif hasattr(response, 'prompt_feedback') and response.prompt_feedback.block_reason:
        block_reason = response.prompt_feedback.block_reason
        return f"AI PR body generation blocked by safety policy (Reason: {block_reason})."
    else:
        return "Gemini generated no text for the PR body. Please write it manually."
except Exception as e:
    logger.error(f"Error generating PR body with Gemini: {e}", exc_info=True)
    return f"Error generating PR body with AI: {e}. Please write it manually."Args:
    issue_id (str): The ID of the issue being fixed.
    patch_diff (str): The suggested code changes in unified diff format.
    diagnosis_details (dict): Information gathered during diagnosis.
    validation_results (dict): Results from validating the patch.

Returns:
    dict: A dictionary indicating the workflow trigger status.
"""
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GITHUB_DISPATCH_TOKEN, GITHUB_PR_WORKFLOW_FILENAME]):
    error_msg = "GitHub Actions Workflow Dispatch configuration missing."
    logger.error(error_msg)
    return {"workflow_url": None, "message": error_msg, "error": error_msg}

repo_owner = diagnosis_details.get('repository_owner') or GIT_REPO_OWNER
repo_name = diagnosis_details.get('repository_name') or GIT_REPO_NAME
base_branch = diagnosis_details.get('base_branch') or DEFAULT_BASE_BRANCH

pr_body = await generate_pr_body_with_gemini(issue_id, patch_diff, diagnosis_details, validation_results)

dispatch_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/actions/workflows/{GITHUB_PR_WORKFLOW_FILENAME}/dispatches"
dispatch_payload = {
    "ref": base_branch,
    "inputs": {
        "issue_id": issue_id,
        "patch_diff": patch_diff,
        "pr_body": pr_body,
        "repo_owner": repo_owner,
        "repo_name": repo_name,
        "base_branch": base_branch,
        "diagnosis_summary": diagnosis_details.get('summary', 'N/A'),
        "validation_summary": validation_results.get('summary', 'N/A'),
        "validation_status": validation_results.get('status', 'Unknown'),
    }
}

dispatch_headers = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {GITHUB_DISPATCH_TOKEN}",
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",
}

async with httpx.AsyncClient() as client:
    try:
        response_dispatch = await client.post(dispatch_url, headers=dispatch_headers, json=dispatch_payload)
        if response_dispatch.status_code == 204:
            workflow_runs_url = f"https://github.com/{repo_owner}/{repo_name}/actions/workflows/{GITHUB_PR_WORKFLOW_FILENAME}"
            return {
                "workflow_url": workflow_runs_url,
                "message": f"Workflow triggered successfully. Check {workflow_runs_url} for details.",
                "error": None
            }
        else:
            error_msg = f"Unexpected status code {response_dispatch.status_code}."
            return {"workflow_url": None, "message": error_msg, "error": error_msg}
    except Exception as e:
        logger.error(f"Error triggering workflow: {e}", exc_info=True)
        return {"workflow_url": None, "message": f"Error: {e}", "error": str(e)}
