# backend/scripts/create_fix_pull_request.py

import json
import traceback
import httpx  # Import the asynchronous HTTP client
import os
import google.generativeai as genai
import base64  # Needed if creating blobs from raw file content (Git Database API)
import logging
import datetime  # Needed for timestamp in branch name

# Setup logger for this module
logger = logging.getLogger(__name__)

# --- Configuration ---
# IMPORTANT: Set these environment variables in your Railway service settings.
GIT_HOST_API_BASE_URL = os.getenv("GIT_HOST_API_BASE_URL", "https://api.github.com")  # Default to GitHub REST API v3
GIT_REPO_OWNER = os.getenv("GIT_REPO_OWNER")  # The owner of the repository (e.g., "your-org")
GIT_REPO_NAME = os.getenv("GIT_REPO_NAME")  # The name of the repository (e.g., "your-repo")
GIT_API_TOKEN = os.getenv("GIT_API_TOKEN")  # GitHub Personal Access Token (PAT) or equivalent
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")  # API key for Google Gemini
DEFAULT_BASE_BRANCH = os.getenv("DEFAULT_BASE_BRANCH", "main")  # Branch to base new fix branches on

# Define standard headers for GitHub API requests (adjust if using a different Git host)
# Ensure token is available before formatting Authorization header
GITHUB_HEADERS = {
    "Accept": "application/vnd.github.v3+json",
    "Authorization": f"token {GIT_API_TOKEN}" if GIT_API_TOKEN else None,
    "X-GitHub-Api-Version": "2022-11-28",
    "Content-Type": "application/json",  # Often needed for POST/PATCH requests
}

# Check for required Git environment variables
if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
    logger.error(
        "Missing one or more required Git environment variables (GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN). "
        "Pull request creation will not work."
    )
    GIT_API_TOKEN = None  # Disable authenticated calls if token is missing
    # Consider raising a more critical error here if PR creation is essential for startup

# Configure Gemini API client (assuming this configuration is sufficient globally)
if GEMINI_API_KEY:
    try:
        # Configure the genai library with the API key
        genai.configure(api_key=GEMINI_API_KEY)
        logger.info("Gemini API configured successfully.")
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {e}", exc_info=True)
        GEMINI_API_KEY = None  # Disable Gemini if configuration fails
else:
    logger.warning("GEMINI_API_KEY environment variable is not set. PR body will not be generated by Gemini.")

# --- Helper function to generate PR body using Gemini (already async) ---
async def generate_pr_body_with_gemini(issue_id: str, code_diff: str, diagnosis_details: dict, validation_results: dict) -> str:
    """
    Generates a professional PR body using the Gemini API asynchronously.

    Args:
        issue_id (str): The ID of the issue.
        code_diff (str): The patch in diff format.
        diagnosis_details (dict): Details from the diagnosis step (e.g., summary).
        validation_results (dict): Results from the validation step (e.g., summary, status).

    Returns:
        str: The generated PR body text, or an informative error message if generation fails.
    """
    if not GEMINI_API_KEY:
        logger.warning("Gemini API key missing, using fallback PR body template for PR body generation.")
        # Fallback template using available data
        diagnosis_summary = diagnosis_details.get('summary', 'N/A')
        validation_summary = validation_results.get('summary', 'N/A')
        code_changes = code_diff if code_diff else "No changes available."
        return f"""
## DebugIQ Automated Pull Request

**Issue ID:** {issue_id}

### Diagnosis Summary:
{diagnosis_summary}

### Validation Results:
{validation_summary}

### Code Changes:
{code_changes}# --- Main asynchronous function to create the Pull Request ---
# THIS IS THE FUNCTION THAT CAN BE IMPORTED BY OTHER SCRIPTS (like autonomous_router.py)
async def create_pull_request(
    issue_id: str,
    patch_diff: str,
    diagnosis_details: dict,
    validation_results: dict
):
    """
    Creates a pull request on the configured Git hosting platform (defaulting to GitHub)
    with the proposed patch. Uses an asynchronous HTTP client for Git API calls.

    Args:
        issue_id (str): The ID of the issue being fixed.
        patch_diff (str): The suggested code changes in unified diff format.
        diagnosis_details (dict): Information gathered during diagnosis. Expected keys might include:
                                  'repository_owner': repo owner (optional, falls back to config)
                                  'repository_name': repo name (optional, falls back to config)
                                  'base_branch': branch to base the PR on (optional, falls back to config)
                                  ... other diagnosis info
        validation_results (dict): Results from validating the patch. Expected keys might include:
                                   'status': 'Passed' or 'Failed',
                                   'summary': validation summary
                                   ... other validation info

    Returns:
        dict: A dictionary containing details about the created PR (e.g., PR URL, PR number),
              or an error key if creation fails. Expected keys: 'pr_url', 'pr_number', 'message', 'error'.
    """
    logger.info(f"Starting PR creation process for issue: {issue_id}")

    # --- Basic Configuration Check ---
    if not all([GIT_REPO_OWNER, GIT_REPO_NAME, GIT_API_TOKEN]):
        error_msg = "Git configuration missing (GIT_REPO_OWNER, GIT_REPO_NAME, or GIT_API_TOKEN). Cannot create pull request."
        logger.error(error_msg)
        return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}
    # Ensure auth header is set if token exists
    if GITHUB_HEADERS["Authorization"] is None:
         error_msg = "Git API token is set but Authorization header is not correctly formed."
         logger.error(error_msg)
         return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}

    # Determine the target repository details - prioritize diagnosis details if available
    repo_owner = diagnosis_details.get('repository_owner') or GIT_REPO_OWNER
    repo_name = diagnosis_details.get('repository_name') or GIT_REPO_NAME

    if not all([repo_owner, repo_name]):
         error_msg = "Repository owner or name not specified in config or diagnosis details."
         logger.error(error_msg)
         return {"pr_url": None, "pr_number": None, "message": error_msg, "error": error_msg}

    logger.info(f"Target Repository: {repo_owner}/{repo_name}")

    # Determine the base branch - prioritize diagnosis details or use default config
    base_branch = diagnosis_details.get('base_branch') or DEFAULT_BASE_BRANCH
    logger.info(f"Base Branch: {base_branch}")

    # Generate a unique branch name for the fix
    # Example: fix/issue-BUG-123-timestamp
    # Ensure branch name is valid (lowercase, hyphens, alphanumeric)
    # Using datetime import for timestamp
    from datetime import datetime # Import datetime if not already at top
    sanitized_issue_id = "".join(c if c.isalnum() or c in ['-'] else '-' for c in str(issue_id)).strip('-')
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    fix_branch_name = f"fix/issue-{sanitized_issue_id}-{timestamp}".replace("--", "-").lower()
    fix_branch_name = fix_branch_name.strip('-')
    if not fix_branch_name:
        fix_branch_name = f"fix/issue-{timestamp}"
    logger.info(f"Proposed Fix Branch: {fix_branch_name}")


    # --- Git API Interaction Logic (Needs Async Implementation) ---
    # THIS SECTION IS CRITICAL AND NEEDS TO BE REPLACED.
    # Replace synchronous 'requests' calls with asynchronous 'httpx' calls and AWAIT them.
    # The steps outlined in the comments are a standard approach for Git Database API (GitHub example).

    # Initialize an async HTTP client for making requests
    async with httpx.AsyncClient() as client:
        try:
            logger.info(f"Starting Git operations via Async HTTP client for {issue_id}")

            # --- Step 1: Get SHA of the latest commit on the base branch ---
            # Use the async client here
            ref_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/ref/heads/{base_branch}"
            logger.debug(f"Getting base branch ref: {ref_url}")
            # --- REPLACE requests.get with await client.get ---
            response_ref = await client.get(ref_url, headers=GITHUB_HEADERS) # AWAIT the async call
            response_ref.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
            base_branch_sha = response_ref.json()['object']['sha']
            logger.info(f"Successfully got base branch ({base_branch}) SHA: {base_branch_sha}")

            # --- Step 2: Create a new branch (ref) based on that commit SHA ---
            # Use the async client here
            create_ref_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/refs"
            create_ref_payload = {
                "ref": f"refs/heads/{fix_branch_name}",
                "sha": base_branch_sha
            }
            logger.debug(f"Creating new branch ref: {create_ref_url} with payload {create_ref_payload}")
            # --- REPLACE requests.post with await client.post ---
            response_create_ref = await client.post(create_ref_url, headers=GITHUB_HEADERS, json=create_ref_payload) # AWAIT the async call
            # Handle 422 specifically if branch already exists
            if response_create_ref.status_code == 422:
                logger.warning(f"Branch '{fix_branch_name}' already exists. Attempting to use existing branch.")
                # In a real implementation, you might need to fetch the existing branch's latest commit SHA here
                # For simplicity, this placeholder proceeds assuming it can use the name or will fail later in commit/ref update.
                pass # You might want to add logic here to fetch the existing branch's tip SHA if needed
            else:
                response_create_ref.raise_for_status()
                logger.info(f"Successfully created new branch: {fix_branch_name}")


            # --- Step 3-8: Apply Patch, Create Blobs, Tree, Commit, Update Ref ---
            # THIS SECTION NEEDS FULL IMPLEMENTATION using the 'client' object and AWAIT.
            # Parse diff, get file SHAs, fetch file contents, apply diff, create blobs, build tree, create commit, update branch ref.
            # You will need to implement the logic to:
            # - Parse the `patch_diff` string. Libraries like `patch` or custom parsing can help.
            # - Identify affected files, lines to add/remove.
            # - Fetch the *current* content of the affected files from the `base_branch`. You might need Git API calls like GET /repos/{owner}/{repo}/contents/{path}?ref={base_branch_sha}. Use `await client.get(...)`.
            # - Apply the `patch_diff` to the fetched content to get the *new* content for each file.
            # - Create new blob objects for each modified/added file using `POST /repos/{owner}/{repo}/git/blobs`. The content might need to be Base64 encoded depending on the API endpoint. Use `await client.post(...)`.
            # - Get the tree SHA of the base commit (`base_branch_sha`). You might need GET /repos/{owner}/{repo}/git/commits/{base_branch_sha} to get the tree SHA. Use `await client.get(...)`.
            # - Create a new tree object representing the state after the patch (POST /repos/{owner}/{repo}/git/trees). Use `await client.post(...)`.
            # - Create a new commit object pointing to the new tree and the base commit using `POST /repos/{owner}/{repo}/git/commits`. Use `await client.post(...)`.
            # - Update the reference of the new branch (`fix_branch_name`) to point to this new commit using `PATCH /repos/{owner}/{repo}/git/refs/heads/{fix_branch_name}`. Use `await client.patch(...)`.

            logger.warning("--- Placeholder: Git content/commit/tree logic needs full implementation using async client ---")
            # Example: Placeholder for the new commit SHA resulted from applying the patch via Git API
            # Replace with the actual SHA from your implementation
            new_commit_sha = "mock_new_commit_sha_67890" # REPLACE with actual commit SHA from your implementation
            logger.info(f"Simulated applying patch and getting new commit SHA: {new_commit_sha}")

            # If using the branch that already existed (status_code 422 above), you typically need to update its ref here
            # url_update_ref = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/git/refs/heads/{fix_branch_name}"
            # update_ref_payload = {"sha": new_commit_sha, "force": True} # force: True might be needed if branch advanced
            # await client.patch(url_update_ref, headers=GITHUB_HEADERS, json=update_ref_payload)


            # --- Step 9: Generate PR Body ---
            # Use the helper function to generate the PR body content (already async)
            pr_body = await generate_pr_body_with_gemini(issue_id, patch_diff, diagnosis_details, validation_results)
            logger.info(f"Generated PR body (snippet): {pr_body[:300]}...") # Log snippet


            # --- Step 10: Create Pull Request ---
            # Use the async client here
            create_pr_url = f"{GIT_HOST_API_BASE_URL}/repos/{repo_owner}/{repo_name}/pulls"
            # Generate a descriptive title
            pr_title = f"Fix for Issue {issue_id}: {diagnosis_details.get('summary', 'Automated fix')[:60]}..." # Example title, truncate to avoid long titles
            # Ensure title is not empty
            if not pr_title.strip():
                 pr_title = f"Automated fix for Issue {issue_id}"


            create_pr_payload = {
                "title": pr_title,
                "body": pr_body,
                "head": fix_branch_name, # The branch with your changes
                "base": base_branch      # The branch you want to merge into
            }
            logger.debug(f"Creating pull request: {create_pr_url} with payload (excluding full body) { {k: v for k, v in create_pr_payload.items() if k != 'body'} }")

            # --- REPLACE requests.post with await client.post ---
            response_create_pr = await client.post(create_pr_url, headers=GITHUB_HEADERS, json=create_pr_payload) # AWAIT the async call
            response_create_pr.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
            pr_details = response_create_pr.json()

            pr_url = pr_details.get('html_url')
            pr_number = pr_details.get('number')

            if pr_url and pr_number is not None:
                 logger.info(f"âœ… Successfully created PR for issue {issue_id}. PR URL: {pr_url}")
                 return {
                     "pr_url": pr_url,
                     "pr_number": pr_number,
                     "message": f"Pull request created successfully for issue {issue_id}. PR: {pr_url}",
                     "error": None # Explicitly set error to None on success
                 }
            else:
                 error_msg = f"PR creation API call succeeded but did not return expected PR URL or number. Response: {pr_details}"
                 logger.error(error_msg)
                 # Include full response in backend_detail for debugging
                 return {"pr_url": None, "pr_number": None, "message": f"PR API Response Error: {error_msg}", "error": error_msg, "backend_detail": backend_detail}


        # --- Use httpx specific exceptions for HTTP errors ---
        except httpx.HTTPStatusError as e:
            # Handle errors during HTTP requests (e.g., 404, 401, 500)
            error_msg = f"Git API HTTP error during PR creation for issue {issue_id}: {e}"
            logger.error(error_msg, exc_info=True)
            backend_detail = "N/A"
            if e.response is not None:
                 try:
                     # Attempt to parse JSON error response, fallback to text
                     if e.response.text: backend_detail = e.response.json()
                     else: backend_detail = "Empty response body"
                 except json.JSONDecodeError:
                      backend_detail = e.response.text[:500] if e.response.text else "Non-JSON response body" # Log snippet
                 error_msg += f" - API Response: {backend_detail}"

            return {"pr_url": None, "pr_number": None, "message": f"Git API HTTP Error: {error_msg}", "error": error_msg, "backend_detail": backend_detail}

        except httpx.RequestError as e:
            # Handle network or request-specific errors (e.g., connection failed, timeout)
            error_msg = f"Git API request error during PR creation for issue {issue_id}: {e}"
            logger.error(error_msg, exc_info=True)
            return {"pr_url": None, "pr_number": None, "message": f"Git API Request Error: {error_msg}", "error": error_msg}

        except Exception as e:
            # Catch any other unexpected errors
            error_msg = f"An unexpected error occurred during PR creation for issue {issue_id}: {e}"
            logger.error(error_msg, exc_info=True)
            return {"pr_url": None, "pr_number": None, "message": f"Unexpected Error: {error_msg}", "error": error_msg}

# Note: This file defines the 'create_pull_request' function which needs to be
# imported and awaited by scripts like autonomous_router.py. It does NOT define an APIRouter.
# You need to install httpx: pip install httpx"""
